// ============================================================================
// Quantiloom - Ray Generation Shader
// ============================================================================
// Generates primary camera rays and writes output to storage image
//
// SPECTRAL RENDERING:
// - Wavelength is set via camera.wavelength_nm (push constants)
// - Output is RGB (for single λ, grayscale; for multi-λ, accumulated bands)
// ============================================================================

#include "common.hlsli"

// ============================================================================
// Bindings
// ============================================================================

[[vk::binding(0, 0)]] RWTexture2D<float4> outputImage;
[[vk::binding(1, 0)]] RaytracingAccelerationStructure scene;
[[vk::binding(2, 0)]] StructuredBuffer<LUTData> skyLUT;

// Push constants: Camera parameters
[[vk::push_constant]] CameraData camera;

// ============================================================================
// Ray Generation Entry Point
// ============================================================================

[shader("raygeneration")]
void main() {
    // Get pixel coordinates
    uint2 launchID = DispatchRaysIndex().xy;
    uint2 launchSize = DispatchRaysDimensions().xy;

    // Convert to normalized device coordinates [0, 1]
    float2 pixelCenter = float2(launchID) + 0.5;
    float2 uv = pixelCenter / float2(launchSize);

    // Convert UV to NDC [-1, 1]
    // Note: Flip Y because screen coordinates are top-down (Y increases downward)
    // but camera up vector points upward
    float2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Flip Y axis

    // Compute ray direction using camera parameters
    float3 direction = normalize(
        camera.forward +
        ndc.x * camera.right * camera.fovScale * camera.aspectRatio +
        ndc.y * camera.up * camera.fovScale
    );

    // Ray origin from camera
    float3 origin = camera.origin;

    // Setup ray
    RayDesc ray;
    ray.Origin = origin;
    ray.Direction = direction;
    ray.TMin = 0.001;   // Avoid self-intersection
    ray.TMax = 10000.0; // Far plane

    // TEMPORARY DEBUG: Test if GPU can write to output without ray tracing
    // This will help identify if the problem is in TraceRay or elsewhere
    #if 1
    // Initialize payload
    Payload payload;
    payload.radiance = float3(0.0, 0.0, 0.0);

    // Trace ray (hit group index 0, miss index 0)
    TraceRay(
        scene,              // Acceleration structure
        RAY_FLAG_NONE,      // Ray flags
        0xFF,               // Instance mask (all instances visible)
        0,                  // SBT ray contribution offset
        0,                  // SBT multiplier
        0,                  // Miss index
        ray,                // Ray descriptor
        payload             // Ray payload
    );

    // Write output (clamp for sanity)
    float3 color = clamp(payload.radiance, 0.0, 100.0);
    outputImage[launchID] = float4(color, 1.0);
    #else
    // DEBUG: Just write UV as color (red = X, green = Y, blue = 0)
    float3 debugColor = float3(uv.x, uv.y, 0.0);
    outputImage[launchID] = float4(debugColor, 1.0);
    #endif
}
